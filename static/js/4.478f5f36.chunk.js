(this["webpackJsonpjonshort.me"]=this["webpackJsonpjonshort.me"]||[]).push([[4],{39:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.withMDXComponents=void 0;var o,a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},r=n(1),s=(o=r)&&o.__esModule?o:{default:o};var l=s.default.createContext({}),i=l.Provider,c=l.Consumer;t.withMDXComponents=function(e){return function(t){return s.default.createElement(c,null,(function(n){return s.default.createElement(e,a({},t,{components:t.components||n}))}))}};t.default=function(e){return s.default.createElement(i,{value:e.components},e.children)}},40:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n(41);Object.defineProperty(t,"MDXTag",{enumerable:!0,get:function(){return r(o).default}});var a=n(39);function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"MDXProvider",{enumerable:!0,get:function(){return r(a).default}})},41:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o,a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},r=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(1),l=(o=s)&&o.__esModule?o:{default:o},i=n(39);function c(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function m(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!==typeof t&&"function"!==typeof t?e:t}var u={inlineCode:"code",wrapper:"div"},p=function(e){function t(){return c(this,t),m(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return function(e,t){if("function"!==typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,e),r(t,[{key:"render",value:function(){var e=this.props,t=e.name,n=e.parentName,o=e.props,r=void 0===o?{}:o,s=e.children,i=e.components,c=void 0===i?{}:i,m=e.Layout,p=e.layoutProps,h=c[n+"."+t]||c[t]||u[t]||t;return m?l.default.createElement(m,a({components:c},p),l.default.createElement(h,r,s)):l.default.createElement(h,r,s)}}]),t}(s.Component);t.default=(0,i.withMDXComponents)(p)},42:function(e,t,n){"use strict";function o(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}n.d(t,"a",(function(){return o}))},46:function(e,t,n){"use strict";n.r(t);var o=n(42),a=n(1),r=n.n(a),s=n(40),l=["components"];t.default=function(e){var t=e.components;Object(o.a)(e,l);return r.a.createElement(s.MDXTag,{name:"wrapper",components:t},r.a.createElement(s.MDXTag,{name:"p",components:t},"\ud83d\udc4d This post was ",r.a.createElement(s.MDXTag,{name:"em",components:t,parentName:"p"},"heavily")," inspired by an awesome ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://rustwasm.github.io/docs/book/introduction.html"}},"tutorial on wasm and rust")),r.a.createElement(s.MDXTag,{name:"h3",components:t},"'Smart' code"),r.a.createElement(s.MDXTag,{name:"p",components:t},"Let's say we have a grid:"),r.a.createElement(s.MDXTag,{name:"pre",components:t},r.a.createElement(s.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-txt",metaString:""}},"[1] [0] [1] [1] [0] [1]\n[1] [0] [0] [1] [0] [1]\n[1] [0] [1] [1] [0] [1]\n[1] [0] [1] [1] [0] [1]\n[1] [0] [1] [1] [0] [1]\n[1] [0] [1] [1] [0] [1]\n")),r.a.createElement(s.MDXTag,{name:"p",components:t},"And my task is to figure out how many cells contain a 1 around a given cell (with wrapping - e.g. rightmost column is considered 'neighbor' to the leftmost)."),r.a.createElement(s.MDXTag,{name:"p",components:t},"You could - as written ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://rustwasm.github.io/docs/book/game-of-life/implementing.html#rust-implementation"}},"in the wasm + rust tutorial")," - write some fancy rust code:"),r.a.createElement("small",null,"note - I've commented this, don't worry about understanding every detail"),r.a.createElement(s.MDXTag,{name:"pre",components:t},r.a.createElement(s.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-rust",metaString:""}},"// Here the user provides coordinates (row and column)\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n\n    // The first for loop runs, with delta_row signifying:\n    // [ ] the cell above\n    // [x] the chosen cell\n    // [ ] the cell below\n    for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n\n        // The second for loop is similar, but because it's\n        // nested, it'll actually run 9 times\n        // [ ] [ ] [ ]\n        // [ ] [x] [ ] chosen cell is now the 'middle'\n        // [ ] [ ] [ ]\n        for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n\n            // when both are 0, it's the current cell\n            // so we don't do anything\n            if delta_row == 0 && delta_col == 0 {\n                continue;\n            }\n\n            // because the grid overflows, we use a delta and\n            // modulo to get the cell the other side; e.g.\n            // [ ] [ ] [B] // 'below' cell is actually above\n            // [ ] [ ] [A]\n            // [R] [L] [C] // 'right' cell is on the other side\n            // e.g. (50 + 1) % 50 == 1\n            let neighbor_row = (row + delta_row) % self.height;\n            let neighbor_col = (column + delta_col) % self.width;\n\n            // implementation detail of how the cells\n            // are stored (flat array), this returns the\n            // index of the current cell\n            let idx = self.get_index(neighbor_row, neighbor_col);\n\n            // an 'alive' cell is 1, so the count is\n            // only incremented if the cell is alive\n            count += self.cells[idx] as u8;\n        }\n    }\n\n    // the final count is returned, which is\n    // the number of 'alive' cells near the current\n    count\n}\n")),r.a.createElement(s.MDXTag,{name:"p",components:t},"As a section of code, this is \ud83d\ude05 ",r.a.createElement(s.MDXTag,{name:"em",components:t,parentName:"p"},"fairly confusing")," \ud83d\ude05 but also quite 'smart'. It can get the value in neighbor cells without worrying about the handling the edges of the grid in an explicit way, e.g. an if statement."),r.a.createElement(s.MDXTag,{name:"h3",components:t},"Profiling"),r.a.createElement(s.MDXTag,{name:"p",components:t},"Our code now fulfils it's purpose, and would probably be considered a 'job done' going by our requirements."),r.a.createElement(s.MDXTag,{name:"p",components:t},"However, the 'smart' modulo operation (%) hides a potential performance hit! It's a 'div instruction' which is division performed on unsigned integers. This means that for every cell in our grid we're performing 16 of these operations, which can be quite expensive."),r.a.createElement(s.MDXTag,{name:"p",components:t},"Here's a benchmark of the rust code, we can see the div instructions in red:\n",r.a.createElement(s.MDXTag,{name:"img",components:t,parentName:"p",props:{src:"https://rustwasm.github.io/docs/book/images/game-of-life/bench-perf-annotate.png",alt:"rust code being benchmarked"}})),r.a.createElement(s.MDXTag,{name:"h3",components:t},"Speeding up the code by removing 'smart stuff'"),r.a.createElement(s.MDXTag,{name:"p",components:t},"As written ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://rustwasm.github.io/docs/book/game-of-life/time-profiling.html#making-time-run-faster"}},"in the wasm + rust tutorial"),", we can make this code less fancy, and acheive a speedup at the same time, by using if statements and no modulo operators."),r.a.createElement(s.MDXTag,{name:"p",components:t},"We rewrite our code to:"),r.a.createElement("small",null,"Again, I've commented this, don't worry about understanding every detail!"),r.a.createElement(s.MDXTag,{name:"pre",components:t},r.a.createElement(s.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-rust",metaString:""}},"// coordinates provided as before\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n\n    // if we're at the top of the grid, north is actually the\n    // bottom of the grid \n    let north = if row == 0 {\n        self.height - 1\n    } else {\n        row - 1\n    };\n\n    // if we're at the bottom of the grid, south is actually\n    // the top of the grid\n    let south = if row == self.height - 1 {\n        0\n    } else {\n        row + 1\n    };\n\n    // if we're at the left of the grid, west is actually\n    // the right of the grid\n    let west = if column == 0 {\n        self.width - 1\n    } else {\n        column - 1\n    };\n\n    // if we're at the right of the grid, east is actually\n    // the left of the grid\n    let east = if column == self.width - 1 {\n        0\n    } else {\n        column + 1\n    };\n\n    // In this section we get the value of all the neighbors\n    // [nw] [n] [ne]    [1] [0] [1]\n    // [w]       [e]  = [0]     [0] = 4\n    // [sw] [s] [se]    [1] [0] [1]\n\n    let nw = self.get_index(north, west);\n    count += self.cells[nw] as u8;\n\n    let n = self.get_index(north, column);\n    count += self.cells[n] as u8;\n\n    let ne = self.get_index(north, east);\n    count += self.cells[ne] as u8;\n\n    let w = self.get_index(row, west);\n    count += self.cells[w] as u8;\n\n    let e = self.get_index(row, east);\n    count += self.cells[e] as u8;\n\n    let sw = self.get_index(south, west);\n    count += self.cells[sw] as u8;\n\n    let s = self.get_index(south, column);\n    count += self.cells[s] as u8;\n\n    let se = self.get_index(south, east);\n    count += self.cells[se] as u8;\n\n    // Then the same as before, we return the count\n    count\n}\n")),r.a.createElement(s.MDXTag,{name:"p",components:t},"So our code is now significantly longer, we're doing a lot of things that look repetitive. A reviewer might ask if there's a way to abstract the logic away; but since we've seen the two different approaches, we can see that the code feels easier to read:"),r.a.createElement(s.MDXTag,{name:"ul",components:t},r.a.createElement(s.MDXTag,{name:"li",components:t,parentName:"ul"},"by using points of a compass we've given readers something tangible to reason about while reading"),r.a.createElement(s.MDXTag,{name:"li",components:t,parentName:"ul"},"no longer do we have to explain that we're using a delta (and potentially why)"),r.a.createElement(s.MDXTag,{name:"li",components:t,parentName:"ul"},"the messy nested for loops are removed")),r.a.createElement(s.MDXTag,{name:"h3",components:t},"The result"),r.a.createElement(s.MDXTag,{name:"pre",components:t},r.a.createElement(s.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-bash",metaString:""}},"$ cargo benchcmp before.txt after.txt\n name            before.txt ns/iter  after.txt ns/iter  diff %  speedup\n universe_ticks  664,421             87,258            -86.87%   x 7.61\n")),r.a.createElement(s.MDXTag,{name:"p",components:t},"The new code actually yields a ",r.a.createElement(s.MDXTag,{name:"em",components:t,parentName:"p"},"7.61x")," speed up!"),r.a.createElement(s.MDXTag,{name:"p",components:t},"We're often pushed to find 'clean one-liner' solutions, or abstract something so we don't repeat ourselves. But sometimes there are benefits in both readability and performance when we make code 'simpler'."),r.a.createElement(s.MDXTag,{name:"p",components:t},"Profiling and getting the best performance out of code can be a useful exercise, but make sure the gains are worth it."),r.a.createElement(s.MDXTag,{name:"p",components:t},"\ud83e\udd13 Thanks for reading, check out the excellent ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://rustwasm.github.io/docs/book/introduction.html"}},"tutorial on wasm and rust")," which gave me the content for this article."),r.a.createElement(s.MDXTag,{name:"p",components:t},"And for rust in general, i highly reccomend ",r.a.createElement(s.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://doc.rust-lang.org/book/"}},"the official rust book"),", it's some of the best documentation i've ever read \ud83e\udd73"))}}}]);
//# sourceMappingURL=4.478f5f36.chunk.js.map